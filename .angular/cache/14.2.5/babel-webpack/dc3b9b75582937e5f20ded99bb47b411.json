{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, PLATFORM_ID, Directive, Input, Output, Self, Component, ChangeDetectionStrategy, ViewChild, NgModule } from '@angular/core';\nimport * as i2 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { from, of, animationFrameScheduler, Subject, BehaviorSubject, defer, Observable } from 'rxjs';\nimport { map, tap, shareReplay, observeOn, filter, switchMap, takeUntil } from 'rxjs/operators';\nimport * as i1 from '@angular/platform-browser';\nimport { makeStateKey } from '@angular/platform-browser';\nconst _c0 = [\"container\"];\nconst LOTTIE_OPTIONS = new InjectionToken('LottieOptions');\n\nfunction convertPlayerOrLoaderToObservable(player, useWebWorker) {\n  const playerOrLoader = player();\n  const player$ = playerOrLoader instanceof Promise ? from(playerOrLoader).pipe(map(module => module.default || module)) : of(playerOrLoader);\n  return player$.pipe(tap(player => player.useWebWorker(useWebWorker)), shareReplay({\n    bufferSize: 1,\n    refCount: true\n  }));\n}\n\nlet AnimationLoader = /*#__PURE__*/(() => {\n  class AnimationLoader {\n    constructor(ngZone, options) {\n      this.ngZone = ngZone;\n      this.options = options;\n      this.player$ = convertPlayerOrLoaderToObservable(this.options.player, this.options.useWebWorker).pipe(observeOn(animationFrameScheduler));\n    }\n\n    loadAnimation(options) {\n      return this.player$.pipe(map(player => this.createAnimationItem(player, options)));\n    }\n\n    resolveOptions(options, container) {\n      return Object.assign({\n        container,\n        renderer: 'svg',\n        loop: true,\n        autoplay: true\n      }, options);\n    }\n\n    createAnimationItem(player, options) {\n      return this.ngZone.runOutsideAngular(() => player.loadAnimation(options));\n    }\n\n  }\n\n  /** @nocollapse */\n  AnimationLoader.ɵfac = function AnimationLoader_Factory(t) {\n    return new (t || AnimationLoader)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(LOTTIE_OPTIONS));\n  };\n  /** @nocollapse */\n\n\n  AnimationLoader.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AnimationLoader,\n    factory: AnimationLoader.ɵfac,\n    providedIn: 'root'\n  });\n  return AnimationLoader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet BaseDirective = /*#__PURE__*/(() => {\n  class BaseDirective {\n    constructor(ngZone, platformId, animationLoader) {\n      this.ngZone = ngZone;\n      this.platformId = platformId;\n      this.animationLoader = animationLoader;\n      this.options = null;\n      this.containerClass = null;\n      this.styles = null;\n      /**\n       * `animationCreated` is dispatched after calling `loadAnimation`.\n       */\n\n      this.animationCreated = this.getAnimationItem();\n      /**\n       * `complete` is dispatched after completing the last frame.\n       */\n\n      this.complete = this.awaitAnimationItemAndStartListening('complete');\n      /**\n       * `loopComplete` is dispatched after completing the frame loop.\n       */\n\n      this.loopComplete = this.awaitAnimationItemAndStartListening('loopComplete');\n      /**\n       * `enterFrame` is dispatched after entering the new frame.\n       */\n\n      this.enterFrame = this.awaitAnimationItemAndStartListening('enterFrame');\n      /**\n       * `segmentStart` is dispatched when the new segment is adjusted.\n       */\n\n      this.segmentStart = this.awaitAnimationItemAndStartListening('segmentStart');\n      /**\n       * Original event name is `config_ready`. `config_ready` is dispatched\n       * after the needed renderer is configured.\n       */\n\n      this.configReady = this.awaitAnimationItemAndStartListening('config_ready');\n      /**\n       * Original event name is `data_ready`. `data_ready` is dispatched\n       * when all parts of the animation have been loaded.\n       */\n\n      this.dataReady = this.awaitAnimationItemAndStartListening('data_ready');\n      /**\n       * Original event name is `DOMLoaded`. `DOMLoaded` is dispatched\n       * when elements have been added to the DOM.\n       */\n\n      this.domLoaded = this.awaitAnimationItemAndStartListening('DOMLoaded');\n      /**\n       * `destroy` will be dispatched when the component gets destroyed,\n       * it's handy for releasing resources.\n       */\n\n      this.destroy = this.awaitAnimationItemAndStartListening('destroy');\n      /**\n       * `error` will be dispatched if the Lottie player could not render\n       * some frame or parse config.\n       */\n\n      this.error = this.awaitAnimationItemAndStartListening('error');\n      this.destroy$ = new Subject();\n      this.loadAnimation$ = new Subject();\n      this.animationItem$ = new BehaviorSubject(null);\n      this.setupLoadAnimationListener();\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroyAnimation();\n    }\n\n    loadAnimation(changes, container) {\n      // The `loadAnimation` may load `lottie-web` asynchronously and also pipes the player\n      // with `animationFrameScheduler`, which schedules an animation task and triggers change\n      // detection. We'll trigger change detection only once when the animation item is created.\n      this.ngZone.runOutsideAngular(() => this.loadAnimation$.next([changes, container]));\n    }\n\n    getAnimationItem() {\n      return defer(() => this.animationItem$).pipe(filter(animationItem => animationItem !== null));\n    }\n\n    awaitAnimationItemAndStartListening(name) {\n      return this.getAnimationItem().pipe(switchMap(animationItem => // `fromEvent` will try to call `removeEventListener` when `unsubscribe()` is invoked.\n      // The problem is that `ngOnDestroy()` is called before Angular unsubscribes from\n      // `@Output()` properties, thus `animationItem` will be `null` already, also `lottie-web`\n      // removes event listeners when calling `destroy()`.\n      new Observable(observer => {\n        this.ngZone.runOutsideAngular(() => {\n          animationItem.addEventListener(name, event => {\n            this.ngZone.runOutsideAngular(() => {\n              observer.next(event);\n            });\n          });\n        });\n      })));\n    }\n\n    setupLoadAnimationListener() {\n      const loadAnimation$ = this.loadAnimation$.pipe(filter(([changes]) => isPlatformBrowser(this.platformId) && changes.options !== undefined));\n      loadAnimation$.pipe(switchMap(([changes, container]) => {\n        this.destroyAnimation();\n        return this.animationLoader.loadAnimation(this.animationLoader.resolveOptions(changes.options.currentValue, container));\n      }), takeUntil(this.destroy$)).subscribe(animationItem => {\n        this.ngZone.run(() => this.animationItem$.next(animationItem));\n      });\n    }\n\n    destroyAnimation() {\n      const animationItem = this.animationItem$.getValue(); // The `ng-lottie` component or the `lottie` directive can be destroyed\n      // before the `animationItem` is set, thus it will fail with\n      // `Cannot read property 'destroy' of null`.\n      // Potentially it can happen if the directive gets destroyed before change\n      // detection is run.\n\n      if (animationItem === null) {\n        return;\n      } // `destroy()` will remove all events listeners.\n\n\n      animationItem.destroy();\n      this.animationItem$.next(null);\n    }\n\n  }\n\n  /** @nocollapse */\n  BaseDirective.ɵfac = function BaseDirective_Factory(t) {\n    return new (t || BaseDirective)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(PLATFORM_ID), i0.ɵɵdirectiveInject(AnimationLoader));\n  };\n  /** @nocollapse */\n\n\n  BaseDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: BaseDirective,\n    selectors: [[\"\", \"lottie\", \"\"]],\n    inputs: {\n      options: \"options\",\n      containerClass: \"containerClass\",\n      styles: \"styles\"\n    },\n    outputs: {\n      animationCreated: \"animationCreated\",\n      complete: \"complete\",\n      loopComplete: \"loopComplete\",\n      enterFrame: \"enterFrame\",\n      segmentStart: \"segmentStart\",\n      configReady: \"configReady\",\n      dataReady: \"dataReady\",\n      domLoaded: \"domLoaded\",\n      destroy: \"destroy\",\n      error: \"error\"\n    }\n  });\n  return BaseDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LottieDirective = /*#__PURE__*/(() => {\n  class LottieDirective extends BaseDirective {\n    constructor(ngZone, platformId, host, animationLoader) {\n      super(ngZone, platformId, animationLoader);\n      this.host = host;\n    }\n\n    ngOnChanges(changes) {\n      super.loadAnimation(changes, this.host.nativeElement);\n    }\n\n  }\n\n  /** @nocollapse */\n  LottieDirective.ɵfac = function LottieDirective_Factory(t) {\n    return new (t || LottieDirective)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(PLATFORM_ID), i0.ɵɵdirectiveInject(i0.ElementRef, 2), i0.ɵɵdirectiveInject(AnimationLoader));\n  };\n  /** @nocollapse */\n\n\n  LottieDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LottieDirective,\n    selectors: [[\"\", \"lottie\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  return LottieDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LottieComponent = /*#__PURE__*/(() => {\n  class LottieComponent extends BaseDirective {\n    constructor(ngZone, platformId, animationLoader) {\n      super(ngZone, platformId, animationLoader);\n      this.width = null;\n      this.height = null;\n      this.container = null;\n    }\n\n    ngOnChanges(changes) {\n      super.loadAnimation(changes, this.container.nativeElement);\n    }\n\n  }\n\n  /** @nocollapse */\n  LottieComponent.ɵfac = function LottieComponent_Factory(t) {\n    return new (t || LottieComponent)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(PLATFORM_ID), i0.ɵɵdirectiveInject(AnimationLoader));\n  };\n  /** @nocollapse */\n\n\n  LottieComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: LottieComponent,\n    selectors: [[\"ng-lottie\"]],\n    viewQuery: function LottieComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n      }\n    },\n    inputs: {\n      width: \"width\",\n      height: \"height\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    decls: 2,\n    vars: 6,\n    consts: [[3, \"ngStyle\", \"ngClass\"], [\"container\", \"\"]],\n    template: function LottieComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0, 1);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"width\", ctx.width || \"100%\")(\"height\", ctx.height || \"100%\");\n        i0.ɵɵproperty(\"ngStyle\", ctx.styles)(\"ngClass\", ctx.containerClass);\n      }\n    },\n    dependencies: [CommonModule, i2.NgClass, i2.NgStyle],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return LottieComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LottieModule = /*#__PURE__*/(() => {\n  class LottieModule {\n    static forRoot(options) {\n      return {\n        ngModule: LottieModule,\n        providers: [{\n          provide: LOTTIE_OPTIONS,\n          useValue: options\n        }]\n      };\n    }\n\n  }\n\n  /** @nocollapse */\n  LottieModule.ɵfac = function LottieModule_Factory(t) {\n    return new (t || LottieModule)();\n  };\n  /** @nocollapse */\n\n\n  LottieModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: LottieModule\n  });\n  /** @nocollapse */\n\n  LottieModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [LottieComponent]\n  });\n  return LottieModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CacheableAnimationLoader = /*#__PURE__*/(() => {\n  class CacheableAnimationLoader extends AnimationLoader {\n    constructor() {\n      super(...arguments);\n      this.cache = new Map();\n    }\n\n    ngOnDestroy() {\n      this.cache.clear();\n    }\n\n    loadAnimation(options) {\n      return this.player$.pipe(map(player => {\n        const animationItem = this.createAnimationItem(player, this.transformOptions(options));\n        this.awaitConfigAndCache(options, animationItem);\n        return animationItem;\n      }));\n    }\n\n    awaitConfigAndCache(options, animationItem) {\n      if (this.isAnimationConfigWithPath(options)) {\n        // Don't wait for the `config_ready` event if it has been cached previously.\n        if (this.cache.has(options.path)) {\n          return;\n        }\n\n        animationItem.addEventListener('config_ready', () => {\n          // See the comments below on why we're storing the animation data as a string.\n          this.cache.set(options.path, JSON.stringify(animationItem['animationData']));\n        });\n      }\n    }\n\n    transformOptions(options) {\n      if (this.isAnimationConfigWithPath(options) && this.cache.has(options.path)) {\n        return { ...options,\n          path: undefined,\n          // Caretaker note: `lottie-web` cannot re-use the `animationData` object between animations, and we\n          // have to retrieve a new object each time an animation is created.\n          // https://github.com/airbnb/lottie-web#html\n          // See comments for the `animationData` property.\n          animationData: JSON.parse(this.cache.get(options.path))\n        };\n      } else {\n        return options;\n      }\n    }\n\n    isAnimationConfigWithPath(options) {\n      return typeof options.path === 'string';\n    }\n\n  }\n\n  /** @nocollapse */\n  CacheableAnimationLoader.ɵfac = /* @__PURE__ */function () {\n    let ɵCacheableAnimationLoader_BaseFactory;\n    return function CacheableAnimationLoader_Factory(t) {\n      return (ɵCacheableAnimationLoader_BaseFactory || (ɵCacheableAnimationLoader_BaseFactory = i0.ɵɵgetInheritedFactory(CacheableAnimationLoader)))(t || CacheableAnimationLoader);\n    };\n  }();\n  /** @nocollapse */\n\n\n  CacheableAnimationLoader.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CacheableAnimationLoader,\n    factory: CacheableAnimationLoader.ɵfac,\n    providedIn: 'root'\n  });\n  return CacheableAnimationLoader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LottieCacheModule = /*#__PURE__*/(() => {\n  class LottieCacheModule {\n    static forRoot() {\n      return {\n        ngModule: LottieCacheModule,\n        providers: [{\n          provide: AnimationLoader,\n          useExisting: CacheableAnimationLoader\n        }]\n      };\n    }\n\n  }\n\n  /** @nocollapse */\n  LottieCacheModule.ɵfac = function LottieCacheModule_Factory(t) {\n    return new (t || LottieCacheModule)();\n  };\n  /** @nocollapse */\n\n\n  LottieCacheModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: LottieCacheModule\n  });\n  /** @nocollapse */\n\n  LottieCacheModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return LottieCacheModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction provideCacheableAnimationLoader() {\n  return [{\n    provide: AnimationLoader,\n    useExisting: CacheableAnimationLoader\n  }];\n}\n\nfunction provideLottieOptions(options) {\n  return [{\n    provide: LOTTIE_OPTIONS,\n    useValue: options\n  }];\n}\n\nfunction transformAnimationFilenameToKey(animation) {\n  const [animationName] = animation.split('.json');\n  return `animation-${animationName}`;\n}\n\nlet LottieTransferState = /*#__PURE__*/(() => {\n  class LottieTransferState {\n    constructor(transferState) {\n      this.transferState = transferState;\n    }\n\n    get(animation) {\n      const animationKey = transformAnimationFilenameToKey(animation);\n      const stateKey = makeStateKey(animationKey);\n      return this.transferState.get(stateKey, null);\n    }\n\n  }\n\n  /** @nocollapse */\n  LottieTransferState.ɵfac = function LottieTransferState_Factory(t) {\n    return new (t || LottieTransferState)(i0.ɵɵinject(i1.TransferState));\n  };\n  /** @nocollapse */\n\n\n  LottieTransferState.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LottieTransferState,\n    factory: LottieTransferState.ɵfac,\n    providedIn: 'root'\n  });\n  return LottieTransferState;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AnimationLoader, BaseDirective, LottieCacheModule, LottieComponent, LottieDirective, LottieModule, LottieTransferState, provideCacheableAnimationLoader, provideLottieOptions, transformAnimationFilenameToKey, CacheableAnimationLoader as ɵCacheableAnimationLoader, LOTTIE_OPTIONS as ɵLOTTIE_OPTIONS }; //# sourceMappingURL=ngx-lottie.mjs.map","map":null,"metadata":{},"sourceType":"module"}